// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// OpticalRight         optical       5               
// SideExpansion        digital_out   E               
// STrack               rotation      4               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// OpticalRight         optical       5               
// SideExpansion        digital_out   E               
// Rotation4            rotation      4               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// OpticalRight         optical       5               
// SideExpansion        digital_out   E               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// OpticalRight         optical       5               
// DigitalOutE          digital_out   E               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// OpticalRight         optical       5               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// STrack               encoder       E, F            
// OpticalRight         optical       5               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// STrack               encoder       E, F            
// OpticalRight         optical       5               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// OpticalLeft          optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// STrack               encoder       E, F            
// ---- END VEXCODE CONFIGURED DEVICES ----
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       C:\Users\mikul                                            */
/*    Created:      Thu Mar 10 2022                                           */
/*    Description:  V5 project                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/

// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// BaseLeftRear         motor         20              
// BaseLeftFront        motor         1               
// BaseRightRear        motor         19              
// BaseRightFront       motor         6               
// BaseLeftMid          motor         11              
// BaseRightMid         motor         8               
// Skills               limit         H               
// Controller1          controller                    
// Inertial             inertial      13              
// LTrack               rotation      18              
// RTrack               rotation      17              
// Flywheel             motor         15              
// Intake               motor         2               
// Expansion            digital_out   G               
// AngleAdjust          digital_out   D               
// Optical              optical       7               
// STrackO              rotation      3               
// HyperCarry           limit         A               
// RollerSide           limit         B               
// FarSide              limit         C               
// STrack               encoder       E, F            
// ---- END VEXCODE CONFIGURED DEVICES ----

#include "vex.h"
#include "vex_controller.h"
#include "kalman.h"
#include "control.h"
#include "chasis.h"
#include "buttonSelector.h"
#include "odometry.h"
#include "odom-chassis.h"
#include "drawField.h"

using namespace vex;

task odometryTask;
task drawFieldTask;
task chassisControlTask;

void auton() {

  task odometryTask(positionTracking);
  //task chassisControlTask(chassisControl);
  task drawFieldTask(drawField);

  disableBreak();

  //bool colord = buttons[0].state;
  bool auto1 = buttons[1].state;
  bool auto2 = buttons[2].state;
  bool auto3 = buttons[3].state;
  bool auto4 = buttons[3].state;

  if(is_skills()){
    // first roller
    timeCtrl("driveb", .2);
    AutoRoller("red", 1);
    //driveTo(12,137,0);
    //driveTo(10,0,0);
    moveRot(.65, 40);
    turn_absolute_inertial(-45);

    // intake first disc
    spinIntake();
    inertial_drive(27.5,85);
    turn_absolute_inertial(90.5);
    stopIntake();

    // second roller
    timeCtrl("driveb", .32);
    AutoRoller("red", 2);
    FwVelocitySet(430, .95);

    // first volley
    spinIntake();
    moveRot(.5,50); //.45
    turn_absolute_inertial(1.0);
    //timeCtrl("", .1);
    inertial_drive(45.5,85);
    //moveToPoint(132, 86 , 70);
    stopIntake();
    //turn_rel_inertial(4.5);
    volley(430); // shoot

    //Grab edge
    //turn_absolute_inertial(-271);
    /*
    turn_absolute_inertial(83.5);
    FwVelocitySet(440, .95);
    spinIntake();
    inertial_drive(30, 30);
    inertial_drive(-31.75, 65);
    */
   
    // 2nd volley - shot edge
    //turn_absolute_inertial(-350);
    //turn_absolute_inertial(10);
    //stopIntake();
    //volley(425);
    turn_absolute_inertial(139);//-214.5
    
    // intake diagonal discs
    spinIntake();
    FwVelocitySet(450, .95);
    inertial_drive(27, 80);
    turn_absolute_inertial(45);
    inertial_drive(35, 60);
    wait(150,msec);

    //third volley
    turn_absolute_inertial(-45.5);//-46
    stopIntake();
    volley(446); //shoot
    turn_absolute_inertial(45);
    inertial_drive(27.5,80);
    
    // intake 3 stack
    FwVelocitySet(460, .95);
    spinIntake();
    inertial_drive(37.1,65); 
    turn_absolute_inertial(178.0);
    timeCtrl("driveb", .35);
    AutoRoller("red", 1);

    moveRot(.75, 60);
    turn_absolute_inertial(263.5);
    inertial_drive(37, 80);
    volley(450);
    turn_absolute_inertial(145);

    inertial_drive(19,90);
    turn_rel_inertial(1);
    turn_absolute_inertial(90.0);
    spinIntake();
    inertial_drive(21, 85);
    inertial_drive(30, 50);
    turn_absolute_inertial(270.5);
    stopIntake();
    timeCtrl("driveb", 1);
    AutoRoller("red", 2);

    // other side

    // intake first disc
    spinIntake();
    FwVelocitySet(440, .95);
    moveRot(.54,50); //.45
    turn_absolute_inertial(182);
    //timeCtrl("", .1);
    inertial_drive(40,80);
    //moveToPoint(132, 86 , 70);
    stopIntake();
    //turn_rel_inertial(4.5);
    volley(440); // shoot

    turn_absolute_inertial(-46.0);
    spinIntake();
    inertial_drive(22, 80);
    FwVelocitySet(445, .95);
    turn_absolute_inertial(-134.0);
    inertial_drive(37, 65);
    turn_absolute_inertial(135);
    volley(445); // shoot

    turn_absolute_inertial(221);

    spinIntake();
    inertial_drive(33, 80);
    // volley
    /*
    FwVelocitySet(465, .95);
    turn_absolute_inertial(136);
    inertial_drive(12, 50);
    stopIntake();
    volley(465); //shoot

    turn_absolute_inertial(38);
    inertial_drive(-51, 95);
    turn_absolute_inertial(45);
    Expansion.set(true);
    timeCtrl("driveb", .3);
    */
    
  } else if(auto1 || HyperCarry.pressing()){
    // roller
    FwVelocitySet(575, .98);
    timeCtrl("driveb", .2);
    timeCtrl("intake", .4);
    moveRot(.3,50);

    //shot pre
    turn_absolute_inertial(-9);
    //turnRot(-.2, 40);
    timeCtrl("index", .32, 100); 
    timeCtrl("",.45);
    timeCtrl("index", .32, 100);
    FwVelocitySet(535, .95); 

    // intake stack
    turn_absolute_inertial(52); 
    inertial_drive(27, 75);
    spinIntake();
    inertial_drive(28,40);
    timeCtrl("", .1);

    // second volley
    turn_absolute_inertial(-41);
    //turnRot(-1.82,40);
    timeCtrl("", .15);
    moveRot(.5,40); //.95
    timeCtrl("index", 1.85, 55);
    FwVelocitySet(0, 0);
    
  
    // intake diagonal
    turn_absolute_inertial(45.1);
    spinIntake();
    inertial_drive(87,80);
    
    // 2nd roller
    turn_absolute_inertial(-90);
    timeCtrl("driveb",.5);
    timeCtrl("intake", .23);
    
  } else if(auto2 || RollerSide.pressing()){
    // roller
    FwVelocitySet(561, 0.95);
    timeCtrl("driveb", .4);
    timeCtrl("intake", .27);
    moveRot(.3,50);
    //Grab disk
    turnRot(-.8,70);
    spinIntake();
    moveRot(1,50);
    moveRot(-1.25,70);
    //Shoot pre
    turn_absolute_inertial(48); 
    moveRot(2,70);
    turn_absolute_inertial(-15);
    longVolley();
    FwVelocitySet(517, 0.95); //570
    //Grab stack
    turn_absolute_inertial(49); 
    spinIntake();
    inertial_drive(13.5, 65);
    inertial_drive(23, 40);
    timeCtrl("", .5);
    //Shoot 3
    turn_absolute_inertial(-37);
    longVolley();
    spinIntake();
    FwVelocitySet(515, 0.95);
    //Get Midline
    moveRot(1.2,30);
    moveRot(-.8,15);
    timeCtrl("", .3);
    timeCtrl("index", .5, 100);
    FwVelocitySet(0,0);

  } else if(auto3 || FarSide.pressing()){
    // intake 1
    FwVelocitySet(529, .95);
    inertial_drive(-20, 60);
    turn_absolute_inertial(90);
    timeCtrl("driveb", .27);
    timeCtrl("intake", .41);
    moveRot(.5,60);
    turn_absolute_inertial(43);
    spinIntake();
    inertial_drive(27,70);

    // 1st volley
    turn_absolute_inertial(107);
    longVolley();

    // intake 
    spinIntake();
    moveRot(1.3, 30);
    moveRot(-1.4, 30);
    turn_absolute_inertial(44);
    inertial_drive(37,55);
    inertial_drive(-18, 55);

    // 2nd volley
    FwVelocitySet(535, .95);
    turn_absolute_inertial(119.75);
    longVolley();
    spinIntake();
    moveRot(1,55);
    moveRot(-1,20);
    timeCtrl("index", 1, 100);
    FwVelocitySet(0, 0);

  } else if(auto4){
    
  }
  else{    
    //inertial_drive(60,80);
    //turn_absolute_inertial(-90);
    //turnToPoint(12,5);
    //waitTilCompletion();
    //driveTo(12,0);
    //waitTilCompletion();
    //turnTo(M_PI/2);
    //waitTilCompletion();
    //turnTo(M_PI/2);
    //disableBreak();
    //turn_absolute_inertial(90);
    //moveToPoint(10, 10, 60);
  }
  
} 

bool locked= false;

void usercontrol() {
  
  // The number of loops we've run
  long ticks = 0;

  int deadzone = 8;

  int defaultRPM = 460;
  int flywheelRPM = defaultRPM;
  
  bool expanded = false;
  // Whether or not the left/right side of the base needs to be stopped
  bool stop_left = true;
  bool stop_right = true;
  
  bool toggle = false;
  bool latch = false;

  drawFieldTask.suspend();
  chassisControlTask.suspend();
  Brain.Screen.clearScreen();

  while (true) {
    // Get the left and right base speeds from the controller
    double left_speed = Controller1.Axis3.position();
    double right_speed = Controller1.Axis2.position();
    double RT_speed = right_speed*.5;
    double LT_speed = left_speed*.5;

    // If the input speed is below our threshold, stop the motors
    if ((left_speed < deadzone && left_speed > -deadzone)) {
      // This condition only calls the stop instruction once        
      BaseLeftRear.stop(brake);
      BaseLeftFront.stop(brake);
      BaseLeftMid.stop(brake);
      stop_left = false;
    }
    // Otherwise spin the motors with the input 
    else {
      /*
      if (left_speed <0){
        left_speed = -((pow(fabs(left_speed), 4 *.4))/pow(100, (4*.4)-1));
      }
      else {
        left_speed = ((pow(fabs(left_speed), 4 *.4))/pow(100, (4*.4)-1)); 
      }
      if((left_speed*right_speed <0)){
        left_speed = .7*left_speed; 
      }
      */
      spin(&BaseLeftRear, left_speed);
      spin(&BaseLeftFront, left_speed);
      spin(&BaseLeftMid, left_speed);
      stop_left = true;
    }

    // This is equivalent to the code above
    if ((right_speed < deadzone && right_speed > -deadzone)) {
      
      BaseRightRear.stop(brake);
      BaseRightFront.stop(brake);
      BaseRightMid.stop(brake);
      stop_right = false;
    } 
    
    else if(left_speed <0 &right_speed >0 ||left_speed >0 &right_speed <0){
      spin(&BaseLeftRear, LT_speed);
      spin(&BaseLeftFront, LT_speed);
      spin(&BaseLeftMid, LT_speed);
      stop_left = true;
      spin(&BaseRightRear, RT_speed);
      spin(&BaseRightFront, RT_speed);
      spin(&BaseRightMid, RT_speed);
      stop_right = true;
    }

    else {
      /*
      if (right_speed <0){
        right_speed = -((pow(fabs(right_speed), 4 *.4))/pow(100, (4*.4)-1));
      }
      else {
        right_speed = ((pow(fabs(right_speed), 4 *.4))/pow(100, (4*.4)-1)); 
      }
      if((right_speed*left_speed) <0){
        right_speed = .7*right_speed; 
      */
      spin(&BaseRightRear, right_speed);
      spin(&BaseRightFront, right_speed);
      spin(&BaseRightMid, right_speed);
      stop_right = true;
    }


    // Get the values for the right front buttons
    bool r1_pressing = Controller1.ButtonR1.pressing();
    bool r2_pressing = Controller1.ButtonR2.pressing();
    // Get the values for the left front buttons
    bool l1_pressing = Controller1.ButtonL1.pressing();
    bool l2_pressing = Controller1.ButtonL2.pressing();


    if (toggle && latch){
      FwVelocitySet( flywheelRPM, .95 );
    } else if(!toggle) {
      FwVelocitySet( 0, 0 );
    }

    if (l1_pressing) {
      if(!latch){ //flip the toggle one time and set the latch
        toggle = !toggle;
        latch = true;
      }
    } else {
      //Once the Bumper is released then then release the latch too
      latch = false;
    }

    if (l2_pressing ){
      if (flywheelRPM == 415){
        AngleAdjust.set(false);
        flywheelRPM = defaultRPM;
        FwVelocitySet(flywheelRPM, .95 );
      }
      else{
        AngleAdjust.set(true);
        flywheelRPM = 415;
        FwVelocitySet(flywheelRPM, .95 );   
      }
    }

    if (r1_pressing) {
      spinIndex();
    }
    else if (r2_pressing) { 
      spinIntake();
    }
    else {
      stopIntake();
    }

    if (Controller1.ButtonUp.pressing()) {
      AngleAdjust.set(true);
      flywheelRPM=415;
      FwVelocitySet( flywheelRPM, .95 );    
    }
    else if (Controller1.ButtonDown.pressing()) {
      AngleAdjust.set(false);
      flywheelRPM = defaultRPM;
      FwVelocitySet( flywheelRPM, .95 );
    } 
    
    if(Controller1.ButtonLeft.pressing()){
      flywheelRPM-=50;
      FwVelocitySet( flywheelRPM, .95 );
    } 
    else if (Controller1.ButtonRight.pressing()){
      flywheelRPM+=50;
      if(flywheelRPM>=600)
        flywheelRPM=600;
      FwVelocitySet( flywheelRPM, .95 );
    }
    else {}

    if(Controller1.ButtonA.pressing()){
    } 
    else if(Controller1.ButtonY.pressing()){}

    if(Controller1.ButtonX.pressing()){
      Expansion.set(true);
      if (expanded){
        SideExpansion.set(true);
      }
      expanded = true;
    } 
    else if (Controller1.ButtonB.pressing()){
      Expansion.set(false);
      SideExpansion.set(false);
    }

    double relRPM = Flywheel.velocity(rpm);
    double actualRPM = relRPM*6;

   // Brain.Screen.setCursor(3, 1);
   // Brain.Screen.print("X: %.1lf Y: %.1lf Theta: %.1lf", xPosGlobal,yPosGlobal, get_rotation());
   // Brain.Screen.setCursor(5, 1);
   // Brain.Screen.print("RPM: %.1lf Actual RPM: %.1lf", relRPM, actualRPM);
    Brain.Screen.drawImageFromFile("logo.png", 1,1);
    Brain.Screen.setCursor(1, 1);
    Brain.Screen.print("Base Temp %.0lf Flywheel Temp: %.0lf Intake temp: %.0lf Heading Theta: %.1lf", 
    BaseRightMid.temperature(celsius), Flywheel.temperature(celsius), Intake.temperature(celsius), get_rotation());
    
    
    Controller1.Screen.setCursor(3, 1);
    Controller1.Screen.print("Set: %.0f Actual: %.0lf", (float)flywheelRPM, relRPM); 

    // Increase the tick count
    ticks += 1;
    wait(20.0, msec);
  }
}

competition Competition;

int main() {
  // Initialize vex's internal components
  vexcodeInit();

  //Set encoders to 0
  RTrack.setPosition(0, deg);
  LTrack.setPosition(0, deg);
  STrack.setPosition(0, deg);

  BaseLeftRear.setPosition(0, turns);
  BaseRightFront.setPosition(0, turns);
  BaseRightMid.setPosition(0, turns);
  BaseLeftMid.setPosition(0, turns);
  BaseLeftFront.setPosition(0, turns);
  BaseRightRear.setPosition(0, turns);

  Flywheel.setPosition(0, deg);

  // Calibrate the inertial sensor, and wait for it to finish
  Inertial.calibrate();
  while(Inertial.isCalibrating()) {
    wait(100, msec);
  }

  if(is_skills()){
    THETA_START = M_PI/2; 
    X_START = 137; //19.1
    Y_START = 10; //8.5
  } else{
    THETA_START = 0; //M_PI
    X_START = 0; //19.1
    Y_START = 0; //8.5
  }

  // Print to the screen when we're done calibrating
  Brain.Screen.setCursor(1, 1);
  Brain.Screen.print("Done Calibrating");

  // Initialize our PIDs and rotation tracking thread
  initialize();

  task fwControl(FwControlTask); //Flywheel control

  /*
  Brain.Screen.pressed( userTouchCallbackPressed );
  Brain.Screen.released( userTouchCallbackReleased );

  // make nice background
  Brain.Screen.setFillColor( vex::color(0x404040) );
  Brain.Screen.setPenColor( vex::color(0x404040) );
  Brain.Screen.drawRectangle( 0, 0, 480, 120 );
  Brain.Screen.setFillColor( vex::color(0x808080) );
  Brain.Screen.setPenColor( vex::color(0x808080) );
  Brain.Screen.drawRectangle( 0, 120, 480, 120 );

  // initial display
  displayButtonControls( 0, false );

  //display things
  Brain.Screen.setFillColor( vex::color(0xFFFFFF) );
  Brain.Screen.setPenColor( vex::color(0xc11f27));
  Brain.Screen.printAt( 0,  135, "  39K  AQP Technologies Inc." );
  */

  Competition.autonomous(auton);
  Competition.drivercontrol(usercontrol);

  while(true) {
    wait(50, msec);
  }
}
